// ESP32 LED ring + touch + web server
// Behavior: same as your last sketch + support for a second small addressable LED strip (2 LEDs)
// and a third aux strip (4 LEDs). The aux strips will "follow" / sync with the main ring for the active style.
// All lighting animations and touch behavior preserved â€” only sync additions for the 4-LED strip added.
// SYNC edits are annotated with "// === SYNC LED2 CHANGE" and "// === SYNC LED3 CHANGE"

#include <WiFi.h>
#include <WebServer.h>
#include <HTTPClient.h>
#include <FastLED.h>

/////////////////////
// CONFIG - EDIT
const char* WIFI_SSID = "HONOR X7c";
const char* WIFI_PASS = "12345678";

#define NUM_LEDS 16
#define DATA_PIN 5        // WS2812 data pin for main ring (change if needed)

// === SYNC LED2 CHANGE: define second/aux strip (2 LEDs)
#define NUM_LEDS2 2                     // === SYNC LED2 CHANGE
#define DATA_PIN2 18                    // === SYNC LED2 CHANGE - set to your aux strip pin
// === SYNC LED3 CHANGE: define third/aux strip (4 LEDs)
#define NUM_LEDS3 4                     // === SYNC LED3 CHANGE
#define DATA_PIN3 19                    // === SYNC LED3 CHANGE - set to your aux strip pin
// ========================================================

#define TOUCH_IS_DIGITAL true
#define TOUCH_PIN 4      // digital touch module OUT -> GPIO33 (change if needed)

// If using native touchRead(), adjust this threshold after testing
const int TOUCH_THRESHOLD = 30; // lower => more sensitive

// Set this to your laptop listener URL for touch events (example below).
const char* LAPTOP_CALLBACK_URL = "http://192.168.213.248:5000/touch"; // <-- change to your laptop IP and port
const unsigned long TOUCH_DEBOUNCE_MS = 600;

/////////////////////
WebServer server(80);
CRGB leds[NUM_LEDS];

// === SYNC LED2 CHANGE: aux strip buffer (2 LEDs)
CRGB leds2[NUM_LEDS2]; // === SYNC LED2 CHANGE

// === SYNC LED3 CHANGE: aux strip buffer (4 LEDs)
CRGB leds3[NUM_LEDS3]; // === SYNC LED3 CHANGE

// Animation state (unchanged)
enum Style {
  STYLE_OFF,
  STYLE_LOADING,
  STYLE_TRAIN,
  STYLE_RAINBOW,
  STYLE_BLINK,
  STYLE_SOLID,
  STYLE_CHASE,
  STYLE_STARTUP,
  STYLE_BLUE_LOADING,
  STYLE_PURPLE_SPEAKING,
  STYLE_YELLOW_PROCESSING,
  STYLE_GREEN,
  STYLE_RED,
  STYLE_ORANGE
};

volatile Style currentStyle = STYLE_OFF;
CRGB solidColor = CRGB::Red;
unsigned long lastAnim = 0;
int animPos = 0;
unsigned long lastTouchTime = 0;

// Edge detection for touch (unchanged)
bool prevTouchState = false;
// === TOUCH CHANGE from last version: only notify once after boot
bool notifiedOnce = false; // when true, do not send further notifications to laptop

/////////////////////
// helper: parse color arg (names or "r,g,b")
CRGB parseColorArg(const String &s) {
  String t = s;
  t.trim();
  t.toLowerCase();
  if (t == "red") return CRGB::Red;
  if (t == "green") return CRGB::Green;
  if (t == "blue") return CRGB::Blue;
  if (t == "white") return CRGB::White;
  if (t == "yellow") return CRGB::Yellow;
  if (t == "purple") return CRGB::Purple;
  if (t.indexOf(',') > 0) {
    int i1 = t.indexOf(',');
    int i2 = t.lastIndexOf(',');
    int a = t.substring(0, i1).toInt();
    int b = t.substring(i1 + 1, i2).toInt();
    int c = t.substring(i2 + 1, i2+4).toInt(); // kept as in previous version
    return CRGB(constrain(a,0,255), constrain(b,0,255), constrain(c,0,255));
  }
  return CRGB::Purple;
}

/////////////////////
// HTTP handlers (unchanged)
void handleRoot() {
  String html = "<h1>ESP32 LED Controller</h1>";
  html += "<p>Use <code>/style?name=loading</code> or <code>/style?name=rainbow</code></p>";
  html += "<p>Available: loading, train, rainbow, blink, solid, chase, off, startup, blue_loading, purple_speaking</p>";
  html += "<p>Also: yellow_processing, green, red, orange</p>";
  server.send(200, "text/html", html);
}

void handleStyle() {
  String name = server.arg("name");
  String colorArg = server.arg("color");
  if (name.length() == 0) {
    server.send(400, "text/plain", "missing 'name' query param");
    return;
  }
  name.toLowerCase();

  if (name == "loading") currentStyle = STYLE_LOADING;
  else if (name == "train") currentStyle = STYLE_TRAIN;
  else if (name == "rainbow") currentStyle = STYLE_RAINBOW;
  else if (name == "blink") currentStyle = STYLE_BLINK;
  else if (name == "chase") currentStyle = STYLE_CHASE;
  else if (name == "solid") {
    currentStyle = STYLE_SOLID;
    if (colorArg.length()) solidColor = parseColorArg(colorArg);
  }
  else if (name == "off") {
    currentStyle = STYLE_OFF;
    // === SYNC LED2 CHANGE & SYNC LED3 CHANGE: clear main + aux strips immediately on OFF
    for (int i = 0; i < NUM_LEDS; ++i) leds[i] = CRGB::Black;
    for (int j = 0; j < NUM_LEDS2; ++j) leds2[j] = CRGB::Black; // === SYNC LED2 CHANGE
    for (int k = 0; k < NUM_LEDS3; ++k) leds3[k] = CRGB::Black; // === SYNC LED3 CHANGE
    FastLED.show(); // update all controllers
  }
  else if (name == "startup") currentStyle = STYLE_STARTUP;
  else if (name == "blue_loading") currentStyle = STYLE_BLUE_LOADING;
  else if (name == "purple_speaking") currentStyle = STYLE_PURPLE_SPEAKING;
  else if (name == "yellow_processing") currentStyle = STYLE_YELLOW_PROCESSING;
  else if (name == "green") currentStyle = STYLE_GREEN;
  else if (name == "red") currentStyle = STYLE_RED;
  else if (name == "orange") currentStyle = STYLE_ORANGE;
  else {
    server.send(400, "text/plain", "unknown style");
    return;
  }

  // reset animation state on style change (non-off handled below)
  if (name != "off") {
    animPos = 0;
    lastAnim = 0;
  }

  server.send(200, "text/plain", "OK - set style to: " + name);
  Serial.printf("Style set to %s\n", name.c_str());
}

void handleStatus() {
  String s = "{\"style\":";
  s += String((int)currentStyle);
  s += ",\"ip\":\"" + WiFi.localIP().toString() + "\"}";
  server.send(200, "application/json", s);
}

void setupServer() {
  server.on("/", HTTP_GET, handleRoot);
  server.on("/style", HTTP_GET, handleStyle);
  server.on("/status", HTTP_GET, handleStatus);
  server.begin();
}

/////////////////////
// Touch -> notify laptop (unchanged signature)
void notifyLaptop() {
  if (strlen(LAPTOP_CALLBACK_URL) == 0) return;
  HTTPClient http;
  http.begin(LAPTOP_CALLBACK_URL);
  int code = http.GET();
  Serial.printf("Touch notify -> %s (code=%d)\n", LAPTOP_CALLBACK_URL, code);
  http.end();
}

/////////////////////
// Helpers for animations
// === SYNC LED2/LED3 CHANGE: setAll now writes all strips so helpers keep aux in sync
void setAll(const CRGB &c) {
  for (int i=0;i<NUM_LEDS;i++) leds[i]=c;
  // === SYNC LED2 CHANGE
  for (int j=0;j<NUM_LEDS2;j++) leds2[j]=c;
  // === SYNC LED3 CHANGE
  for (int k=0;k<NUM_LEDS3;k++) leds3[k]=c;
  FastLED.show();
}

// loading: single white pixel rotating
void animateLoading() {
  unsigned long now = millis();
  if (now - lastAnim < 80) return;
  lastAnim = now;
  for (int i=0;i<NUM_LEDS;i++) leds[i] = CRGB::Black;
  leds[animPos] = CRGB::White;
  animPos = (animPos + 1) % NUM_LEDS;
  FastLED.show();
}

// train: block of 4 colorful pixels
void animateTrain() {
  unsigned long now = millis();
  if (now - lastAnim < 120) return;
  lastAnim = now;
  for (int i=0;i<NUM_LEDS;i++) leds[i] = CRGB::Black;
  for (int k=0;k<4;k++) {
    int idx = (animPos + k) % NUM_LEDS;
    leds[idx] = CHSV((animPos*8 + k*20) & 255, 255, 200);
  }
  animPos = (animPos + 1) % NUM_LEDS;
  FastLED.show();
}

// rainbow: continuous rainbow
void animateRainbow() {
  unsigned long now = millis();
  if (now - lastAnim < 20) return;
  lastAnim = now;
  for (int i=0;i<NUM_LEDS;i++) {
    leds[i] = CHSV((i * 255 / NUM_LEDS + animPos) & 255, 255, 180);
  }
  animPos = (animPos + 1) & 255;
  FastLED.show();
}

// blink: on/off
void animateBlink() {
  unsigned long now = millis();
  if (now - lastAnim < 400) return;
  lastAnim = now;
  static bool on = false;
  on = !on;
  if (on) setAll(CRGB::White);
  else setAll(CRGB::Black);
}

// chase: small orange chase
void animateChase() {
  unsigned long now = millis();
  if (now - lastAnim < 80) return;
  lastAnim = now;
  for (int i=0;i<NUM_LEDS;i++) leds[i] = CRGB::Black;
  leds[animPos] = CRGB::Orange;
  leds[(animPos+NUM_LEDS-2)%NUM_LEDS] = CRGB::Yellow;
  animPos = (animPos + 1) % NUM_LEDS;
  FastLED.show();
}

// startup: fill then fade (warm white)
void animateStartup() {
  unsigned long now = millis();
  if (now - lastAnim < 60) return;
  lastAnim = now;

  int cycleLen = NUM_LEDS * 2;
  int pos = animPos % cycleLen;
  int fill;
  if (pos < NUM_LEDS) fill = pos;
  else fill = cycleLen - pos;

  for (int i=0;i<NUM_LEDS;i++) {
    if (i <= fill) {
      uint8_t b = 120 + (uint8_t)((uint16_t)(i * (135 / max(1, NUM_LEDS-1))));
      leds[i] = CRGB(b, b-10, b-30);
    } else {
      leds[i] = CRGB::Black;
    }
  }

  animPos = (animPos + 1) % cycleLen;
  FastLED.show();
}

// blue_loading: blue pixel with tail
void animateBlueLoading() {
  unsigned long now = millis();
  if (now - lastAnim < 70) return;
  lastAnim = now;

  int tail = 4;
  for (int i=0;i<NUM_LEDS;i++) leds[i] = CRGB::Black;
  for (int k=0;k<tail;k++) {
    int idx = (animPos - k + NUM_LEDS) % NUM_LEDS;
    int brightness = 255 - k * 60;
    if (brightness < 0) brightness = 0;
    leds[idx] = CRGB(0, 0, brightness);
  }
  animPos = (animPos + 1) % NUM_LEDS;
  FastLED.show();
}

// purple_speaking: pulsing purple
void animatePurpleSpeaking() {
  unsigned long now = millis();
  if (now - lastAnim < 25) return;
  lastAnim = now;

  animPos = (animPos + 4) & 255;
  uint8_t tri = (uint8_t)animPos;
  if (tri > 127) tri = 255 - tri;
  uint8_t val = tri * 2;

  for (int i=0;i<NUM_LEDS;i++) {
    leds[i] = CHSV(170, 200, val);
  }
  FastLED.show();
}

// yellow_processing - train-like but yellow tones
void animateYellowProcessing() {
  unsigned long now = millis();
  if (now - lastAnim < 110) return;
  lastAnim = now;
  for (int i=0;i<NUM_LEDS;i++) leds[i] = CRGB::Black;

  int len = 4; // length of the yellow train
  for (int k=0;k<len;k++) {
    int idx = (animPos + k) % NUM_LEDS;
    int b = 200 - k * 35; // decreasing brightness along tail
    if (b < 0) b = 0;
    leds[idx] = CRGB(b, b, 0); // yellow-ish (R,G)
  }
  animPos = (animPos + 1) % NUM_LEDS;
  FastLED.show();
}

/////////////////////
// === SYNC LED2/LED3 CHANGE: helper function to sync aux strips to the ring
// This runs AFTER an animation step and updates leds2[] and leds3[] to reflect the current ring state.
// Call this from loop() after the animation switch. It will call FastLED.show() after updating buffers.
void syncAuxStripsToRing() { // === SYNC LED2 CHANGE / SYNC LED3 CHANGE
  // Decide head index on ring: animations increment animPos after drawing head,
  // so the head we want to mirror is animPos-1 (modulo NUM_LEDS).
  int head = (animPos + NUM_LEDS - 1) % NUM_LEDS;

  // ------------------- AUX (2 LED) logic (existing style) -------------------
  CRGB c0 = CRGB::Black;
  CRGB c1 = CRGB::Black;

  switch (currentStyle) {
    case STYLE_BLUE_LOADING:
      c0 = CRGB(0, 0, 255);
      c1 = CRGB(0, 0, 120);
      break;
    case STYLE_LOADING:
      c0 = CRGB::White;
      c1 = CRGB(80,80,80);
      break;
    case STYLE_TRAIN:
      c0 = leds[head];
      c1 = leds[(head + NUM_LEDS - 1) % NUM_LEDS];
      break;
    case STYLE_YELLOW_PROCESSING:
      c0 = CRGB(255, 220, 0);
      c1 = CRGB(150, 130, 0);
      break;
    case STYLE_PURPLE_SPEAKING:
      c0 = CHSV(170, 200, 160);
      c1 = CHSV(170, 200, 80);
      break;
    case STYLE_RAINBOW:
      c0 = CHSV((head * 255 / NUM_LEDS) & 255, 255, 160);
      c1 = CHSV(((head + 3) * 255 / NUM_LEDS) & 255, 255, 120);
      break;
    case STYLE_SOLID:
      c0 = solidColor;
      c1 = solidColor;
      break;
    case STYLE_GREEN:
      c0 = CRGB::Green; c1 = CRGB::Green; break;
    case STYLE_RED:
      c0 = CRGB::Red; c1 = CRGB::Red; break;
    case STYLE_ORANGE:
      c0 = CRGB::Orange; c1 = CRGB::Orange; break;
    case STYLE_OFF:
      c0 = CRGB::Black; c1 = CRGB::Black; break;
    default:
      c0 = leds[0];
      c1 = leds[1 % NUM_LEDS];
      break;
  }

  leds2[0] = c0;
  leds2[1] = c1;

  // ------------------- AUX (4 LED) logic (NEW) -------------------  // === SYNC LED3 CHANGE
  // We'll map 4 aux LEDs to reflect head + a few trailing pixels (or solid/pulse)
  CRGB a0 = CRGB::Black;
  CRGB a1 = CRGB::Black;
  CRGB a2 = CRGB::Black;
  CRGB a3 = CRGB::Black;

  switch (currentStyle) {
    case STYLE_BLUE_LOADING:
      // brightest -> dim tail
      a0 = CRGB(0,0,255);
      a1 = CRGB(0,0,180);
      a2 = CRGB(0,0,100);
      a3 = CRGB(0,0,50);
      break;

    case STYLE_LOADING:
      a0 = CRGB::White;
      a1 = CRGB(150,150,150);
      a2 = CRGB(90,90,90);
      a3 = CRGB(40,40,40);
      break;

    case STYLE_TRAIN:
      // Map head and previous three pixels
      a0 = leds[head];
      a1 = leds[(head + NUM_LEDS - 1) % NUM_LEDS];
      a2 = leds[(head + NUM_LEDS - 2) % NUM_LEDS];
      a3 = leds[(head + NUM_LEDS - 3) % NUM_LEDS];
      break;

    case STYLE_YELLOW_PROCESSING:
      a0 = CRGB(255,220,0);
      a1 = CRGB(210,180,0);
      a2 = CRGB(170,140,0);
      a3 = CRGB(120,100,0);
      break;

    case STYLE_PURPLE_SPEAKING:
      // pulse mapping: use same brightness as ring but scaled
      a0 = CHSV(170,200,200);
      a1 = CHSV(170,200,160);
      a2 = CHSV(170,200,120);
      a3 = CHSV(170,200,80);
      break;

    case STYLE_RAINBOW:
      // pick 4 hues near head position
      a0 = CHSV((head * 255 / NUM_LEDS) & 255, 255, 160);
      a1 = CHSV(((head + 2) * 255 / NUM_LEDS) & 255, 255, 140);
      a2 = CHSV(((head + 4) * 255 / NUM_LEDS) & 255, 255, 120);
      a3 = CHSV(((head + 6) * 255 / NUM_LEDS) & 255, 255, 100);
      break;

    case STYLE_SOLID:
      a0 = solidColor; a1 = solidColor; a2 = solidColor; a3 = solidColor;
      break;

    case STYLE_GREEN:
      a0 = CRGB::Green; a1 = CRGB::Green; a2 = CRGB::Green; a3 = CRGB::Green;
      break;

    case STYLE_RED:
      a0 = CRGB::Red; a1 = CRGB::Red; a2 = CRGB::Red; a3 = CRGB::Red;
      break;

    case STYLE_ORANGE:
      a0 = CRGB::Orange; a1 = CRGB::Orange; a2 = CRGB::Orange; a3 = CRGB::Orange;
      break;

    case STYLE_OFF:
      a0 = CRGB::Black; a1 = CRGB::Black; a2 = CRGB::Black; a3 = CRGB::Black;
      break;

    default:
      // default: mirror first four pixels of ring (or repeat if ring smaller)
      a0 = leds[0];
      a1 = leds[1 % NUM_LEDS];
      a2 = leds[2 % NUM_LEDS];
      a3 = leds[3 % NUM_LEDS];
      break;
  }

  leds3[0] = a0;
  leds3[1] = a1;
  leds3[2] = a2;
  leds3[3] = a3;

  // update hardware (FastLED.show updates all controllers)
  FastLED.show();
}

/////////////////////
void setup() {
  Serial.begin(115200);
  delay(100);

  // Add both auxiliary strips as separate controllers
  FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS);
  // === SYNC LED2 CHANGE: initialize aux strip controller
  FastLED.addLeds<NEOPIXEL, DATA_PIN2>(leds2, NUM_LEDS2); // === SYNC LED2 CHANGE
  // === SYNC LED3 CHANGE: initialize third aux strip controller
  FastLED.addLeds<NEOPIXEL, DATA_PIN3>(leds3, NUM_LEDS3); // === SYNC LED3 CHANGE

  // Ensure we start with LEDs off (all strips)
  for (int i = 0; i < NUM_LEDS; ++i) leds[i] = CRGB::Black;
  for (int j = 0; j < NUM_LEDS2; ++j) leds2[j] = CRGB::Black; // === SYNC LED2 CHANGE
  for (int k = 0; k < NUM_LEDS3; ++k) leds3[k] = CRGB::Black; // === SYNC LED3 CHANGE
  FastLED.show();

  // WiFi connect
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("Connecting to WiFi");
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(250);
    Serial.print(".");
    if (millis() - start > 20000) break;
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("WiFi connected!");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("WiFi connect failed - continuing anyway (no AP mode).");
  }

  // touch pin setup
  if (TOUCH_IS_DIGITAL) {
    pinMode(TOUCH_PIN, INPUT);
    prevTouchState = (digitalRead(TOUCH_PIN) == HIGH); // initialize prev state
  } else {
    prevTouchState = false;
  }

  // === TOUCH CHANGE: ensure notifiedOnce is reset at boot
  notifiedOnce = false; // first-touch notification allowed once per boot

  setupServer();
}

void loop() {
  server.handleClient();

  // ---- TOUCH read with edge detection & debounce (touched state read is unchanged) ----
  bool currentTouched = false;
  if (TOUCH_IS_DIGITAL) {
    currentTouched = (digitalRead(TOUCH_PIN) == HIGH);
  } else {
    int val = touchRead(TOUCH_PIN);
    currentTouched = (val < TOUCH_THRESHOLD); // adjust threshold per your board
  }

  // detect change in touch state
  if (currentTouched != prevTouchState) {
    prevTouchState = currentTouched;

    // If touch became active (rising edge)
    if (currentTouched) {
      // === TOUCH CHANGE: only notify laptop ONCE after boot
      if (!notifiedOnce) {
        // apply debounce: ignore if too soon since last notify
        if (millis() - lastTouchTime > TOUCH_DEBOUNCE_MS) {
          Serial.println("TOUCH detected! (first-edge -> notifying laptop)");
          notifyLaptop();
          lastTouchTime = millis();
          notifiedOnce = true; // ensure we do NOT notify again this boot. // === TOUCH CHANGE
        } else {
          Serial.println("Touch edge detected but ignored due to debounce (first-notify)");
        }
      } else {
        // We have already notified once; do not send again
        Serial.println("TOUCH detected (but already notified once) - not forwarding to laptop"); // === TOUCH CHANGE
      }
    } else {
      // touch released / toggled off
      Serial.println("Touch state: RELEASED/OFF");
    }
  }
  // -------------------------------------------------------------------------------------

  // run the chosen animation (non-blocking). Lighting code unchanged.
  switch (currentStyle) {
    case STYLE_LOADING: animateLoading(); break;
    case STYLE_TRAIN: animateTrain(); break;
    case STYLE_RAINBOW: animateRainbow(); break;
    case STYLE_BLINK: animateBlink(); break;
    case STYLE_SOLID: setAll(solidColor); break;
    case STYLE_CHASE: animateChase(); break;
    case STYLE_STARTUP: animateStartup(); break;
    case STYLE_BLUE_LOADING: animateBlueLoading(); break;
    case STYLE_PURPLE_SPEAKING: animatePurpleSpeaking(); break;
    case STYLE_YELLOW_PROCESSING: animateYellowProcessing(); break;
    case STYLE_GREEN: setAll(CRGB::Green); break;
    case STYLE_RED: setAll(CRGB::Red); break;
    case STYLE_ORANGE: setAll(CRGB::Orange); break;
    case STYLE_OFF:
      // enforce OFF state
      setAll(CRGB::Black);
      break;
    default: /* nothing */ break;
  }

  // === SYNC LED2/LED3 CHANGE:
  // After the ring animation step executes (and usually called FastLED.show()),
  // update the aux 2-LED and 4-LED strips to follow the ring.
  syncAuxStripsToRing(); // updates leds2[] and leds3[] and calls FastLED.show()
}
